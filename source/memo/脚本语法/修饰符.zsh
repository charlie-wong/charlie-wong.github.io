# NOTE 修饰符 -> 单词指示符之后, 每个修饰符需要添加冒号前缀
foo='/d2/d3/d4/d5/d6'; bar='~/abc'
a   # 相对路径转换为绝对路径
A   # 相对路径转换为绝对路径, 结果 `realpath` 处理
ls ~/abc; echo !!-1:a; echo "${bar:a}"
hN  # 按目录分隔路径, 仅保留前 N 个路径, N 省略时仅删除最后部分
h   # 删除路径中最后文件名部分, 即显示文件所在目录, 类似 `dirname` 命令
tN  # 按目录分隔后, 删除开头的所有路径, 仅保留最后的 N 个
t   # 仅保留最后部分, 即文件名或目录名
echo ${foo:h1}  # 显示 /
echo ${foo:h3}  # 显示 /d2/d3
echo ${foo:h}   # 显示 /d2/d3/d4/d5
echo ${foo:t3}  # 显示 d4/d5/d6
echo ${foo:t2}  # 显示 d5/d6
echo ${foo:t}   # 显示 d6
r   # 仅删除文件扩展名, 点后部分(不包含.字符和/字符的部分)
l   # 全部转换为小写
u   # 全部转换为大写

# NOTE s/旧值/新值/ 替换命令中的 / 分界符可用其它字符代替, 例如 s#旧值#新值#
# - [旧值] 通常是字面含义字符串
# - [新值] 中若出现 & 字符, 则表示 [旧值], 即 [新值] 中 & 是有特殊含义的元字符
#   取消其元字符含义则需要对其进行转义 \&
foo="aaa one two foo bar one two foo bar zzz"
s/旧值/新值     # 字符串替换, 最后 / 可省略
s/旧值/新值/    # [新值] 替换 [旧值], 仅替换首次匹配项
s/旧值/新值/:G  # 全部替换
gs/旧值/新值    # 全部替换
gs/旧值/新值/   # 全部替换
&               # 重复前一个替换命令, 即前一个 s
echo "${foo:gs/one/111}"    # 替换所有的 one
echo "${foo:s/one/111/:G}"  # 替换所有的 one  TODO 语法错误?
echo "${foo:s/one/111}"     # 仅替换第一个 one
echo "${foo:&}"  # 重复前一次替换操作
echo "${foo:g&}" # 重复前一次替换操作, 全部替换
echo "${foo:gs/one/11&22}"  # 将所有的 one 替换成 11one22
